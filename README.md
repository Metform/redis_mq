## Первое задание(first)

После установки зависимостей:

- Запуск(в first папке). Предполагается что у вас работает Redis Server v3.0.504 на 6379(по умолчанию) порту.
  - `node starter.js` запуск приложения
  - `node starter.js getErrors` вернет в консоль список всех ошибочных сообщений, getErrors вторым параметром
  
###### 1. доп. вопрос

 Для определения кто станет генератором в случае его сбоя, в данной реализации будет первый воркер достигнувший конца очереди и не получивший новых сообщений в течение 2 секунд. Можно использовать тот же циклический алгоритм или сравнивать по поличеству мощностей системы воркера или рандомно, но для такого подхода нужно устраивать голосование между воркерами, что усложняет реализацию, также можно доабвить дополнительный внешний редис клиент(диспетчер) который через подписку будет следить за состоянием генератора и при необходимости назначать более подходящего воркера, что освободит воркеров от голосований и проверки на наличие генаратора, но в таком случае в системе будет критический элемент при отказе которого возможен отказ всей системы после отказа генератора. Также можно было добавить брокера через который можно было бы более эффективно управлять очередями, генератором, и воркерами, через него также можно было бы добавить очередь результатов, но проблема отказа всей системы останется. К тому же сама нода редеса является критическим элементом, при отключении которого перестанет работать вся система, в таком случае можно использовать кластер нод редиса. Еще можно было бы реализовать восстановление упавших клиентов редиса с помощью менеджера процессов, например pm2.
 Для того чтобы сделать обработку сообщений уникальной я использовал очередь в которую пишет сообщения генератор и последовательно считывают сообщения воркеры. Для синхронного доступа к очереди сообщений я использовал блокирующий pop, что позволяет избежать одновременного изменения очереди сообщений. Вместо очереди можно было бы использовать pub/sub но в таком случае нужно было бы дополнительно обеспечить получение сообщений эксклюзивно для каждого обработчика, этот способ может подойти например если потребуется большая вычислительная мощность для заданий, то издатель мог бы помечать каждое задание для каждого воркера, выступая в роли балансирощика. Если у нас много сообщений можно было бы выделить несколько очередей для групп обработчиков. Можно настроить сохранение на диск для большей надежности. Еще можно было бы добавить логгирование.
  Для реализации больее надежной очереди сообщений можно было бы использовать сторонние библиотеки или например использовать что-нибудь типа брокера RabbitMq
  
###### 2. доп. вопрос

 Если в моей системе несколько процессов(форков) используют один источник(nosql бд, кэш) обычно я делаю что-то наподобие мьютекса, при регистрации(форке) новых процессов из мастера вешаю им обработчик в котором проверяется есть ли блокировки(другими форками) и когда заблокированный форк закончит писать в файл например он отправит всем сообщение что разблокирует очередь из ожидающих процессов, процессы сами по себе не подвержены гонкам так как не используют общую память, а общаются через сообщения через ipc с мастером а он достает эти сообщения из очереди(ивент лупа) что гарантирует что он прочитает их последовательно.
 Часто приходится бороться с гонками при чтении и записи кэша, в редиси к счастью есть "транзакции" в связки с вотчем

## Второе задание(second.js)
  `node second.js <размер>` размер больше нуля
  
  Сделал двумя способами, первый разворачивает матрицу от центра по часовой стрелке, второй наоборот от нижнего левого элемента к центру, потом выводит в обратном порядке
